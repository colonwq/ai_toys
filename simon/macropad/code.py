# simple_simon_macropad.py
#
# This script implements a Simple Simon game on the Adafruit Macropad.
# It uses the 12-key keypad for input, the NeoPixels for visual feedback,
# the built-in speaker for audio feedback, and the OLED display to show game stats.

import time
import random
import board
# Removed direct keypad import as MacroPad handles it
# import keypad
import neopixel # Still needed for NeoPixel class for initialization flexibility
# Removed audiopwmio as macropad.start_tone handles audio output
# import audiopwmio
import array # Still needed for array manipulation if other parts of code still use it (not for tone generation now)
import math

# Import the MacroPad library
from adafruit_macropad import MacroPad

# For the OLED display
import displayio
import terminalio
from adafruit_display_text import label

# --- Hardware Setup ---

# Initialize the MacroPad object. This provides access to all Macropad hardware.
macropad = MacroPad()

# The MacroPad object gives us direct access to the keys, pixels, and audio.
# The `brightness` and `auto_write` are configured here for `macropad.pixels`.
macropad.pixels.brightness = 0.3
macropad.pixels.auto_write = False


# The generate_tone function is no longer needed as macropad.start_tone handles tone generation directly.
# def generate_tone(frequency, duration_ms, sample_rate=8000):
#     length = sample_rate * duration_ms // 1000
#     # Generate a sine wave with values from 0-65535 for 16-bit audio
#     sine_wave = array.array("H", [0] * length)
#     for i in range(length):
#         sine_wave[i] = int(math.sin(i * 2 * math.pi * frequency / sample_rate) * (2**15 - 1) + 2**15)
#     return sine_wave

# OLED Display Setup
# macropad.display is already initialized by MacroPad()
display = macropad.display
# Create a display group to hold elements on the OLED
main_group = displayio.Group()
# Corrected: Replaced display.show(main_group) with display.root_group = main_group
display.root_group = main_group

# Create text labels for the OLED display
current_length_label = label.Label(terminalio.FONT, text="Current: 0", color=0xFFFFFF, x=10, y=10)
max_length_label = label.Label(terminalio.FONT, text="Max: 0", color=0xFFFFFF, x=10, y=30)
game_status_label = label.Label(terminalio.FONT, text="Press any key to start!", color=0xFFFFFF, x=10, y=50, scale=1)

main_group.append(current_length_label)
main_group.append(max_length_label)
main_group.append(game_status_label)

# --- Game Configuration ---

# Define distinct colors for each of the 12 keys (0-11)
# These are RGB hexadecimal values.
KEY_COLORS = [
    0xFF0000, # Red (Key 0)
    0xFF7F00, # Orange (Key 1)
    0xFFFF00, # Yellow (Key 2)
    0x00FF00, # Green (Key 3)
    0x0000FF, # Blue (Key 4)
    0x4B0082, # Indigo (Key 5)
    0x9400D3, # Violet (Key 6)
    0xFF00FF, # Magenta (Key 7)
    0x00FFFF, # Cyan (Key 8)
    0xFFFFFF, # White (Key 9)
    0xAA0000, # Dark Red (Key 10)
    0x00AA00, # Dark Green (Key 11)
]

# Define distinct tones (frequencies in Hz) for each of the 12 keys
KEY_TONES = [
    262, # C4 (Key 0)
    294, # D4 (Key 1)
    330, # E4 (Key 2)
    349, # F4 (Key 3)
    392, # G4 (Key 4)
    440, # A4 (Key 5)
    494, # B4 (Key 6)
    523, # C5 (Key 7)
    587, # D5 (Key 8)
    659, # E5 (Key 9)
    698, # F5 (Key 10)
    784, # G5 (Key 11)
]

TONE_DURATION_MS = 150 # Duration for each tone and LED flash in milliseconds

# --- Game State Variables ---
game_sequence = []       # Stores the sequence generated by the game
player_input_sequence = [] # Stores the sequence entered by the player
current_level = 0        # Current length of the sequence
max_level_achieved = 0   # Highest level reached in any game session
game_over = True         # Flag to indicate if the game is over
game_started = False     # Flag to indicate if the game has started for the first time

# --- Helper Functions ---

# Function to update the OLED display
def update_oled():
    current_length_label.text = f"Current: {current_level}"
    max_length_label.text = f"Max: {max_level_achieved}"
    # Update the display to show changes
    display.root_group = main_group

# Function to play a tone and light up an LED for a specific key
def play_feedback(key_index):
    if key_index is not None and 0 <= key_index < 12:
        # Light up the LED using macropad.pixels
        macropad.pixels[key_index] = KEY_COLORS[key_index]
        macropad.pixels.show()

        # Play the tone using macropad.start_tone
        macropad.start_tone(KEY_TONES[key_index])

        # Keep LED on and tone playing for a short duration
        time.sleep(TONE_DURATION_MS / 1000.0)

        # Turn off the LED and stop the tone
        macropad.pixels[key_index] = 0x000000 # Turn off LED
        macropad.pixels.show()
        macropad.stop_tone()
    else:
        # If key_index is out of bounds or None, just sleep for the duration
        time.sleep(TONE_DURATION_MS / 1000.0)


# Function to play the entire game sequence
def play_game_sequence():
    game_status_label.text = "Watch the sequence!"
    update_oled()
    # Turn off all pixels before playing the sequence
    macropad.pixels.fill(0x000000)
    macropad.pixels.show()
    time.sleep(0.5) # Short pause before playing

    for key_index in game_sequence:
        play_feedback(key_index)
        time.sleep(0.1) # Short pause between sequence elements

    macropad.pixels.fill(0x000000) # Ensure all pixels are off after sequence
    macropad.pixels.show()
    game_status_label.text = "Your turn!"
    update_oled()

# Function to get player input
def get_player_input(expected_length):
    player_input_sequence.clear() # Clear previous input
    game_status_label.text = "Your turn!"
    update_oled()

    start_time = time.monotonic()
    # Give player some time to input the sequence, e.g., 5 seconds per key
    timeout = expected_length * 5 # 5 seconds per key

    while len(player_input_sequence) < expected_length:
        # Get key events using macropad.keys.events.get()
        event = macropad.keys.events.get()
        if event:
            if event.pressed:
                # Key pressed: provide feedback and record it
                key_index = event.key_number
                play_feedback(key_index) # Show feedback immediately
                player_input_sequence.append(key_index)
                # print(f"Player pressed: {key_index}") # For debugging
                # Check for incorrect input immediately
                if len(player_input_sequence) > len(game_sequence) or \
                   player_input_sequence[-1] != game_sequence[len(player_input_sequence) - 1]:
                    return False # Incorrect input, end turn
        
        # Check for timeout
        if time.monotonic() - start_time > timeout:
            return False # Timeout, end turn
        
        # Update encoder switch debouncing, as recommended for macropad usage
        macropad.encoder_switch_debounced.update()

        time.sleep(0.01) # Small delay to prevent busy-waiting

    return True # All expected input received and correct so far

# Function to provide positive feedback
def success_feedback():
    game_status_label.text = "Correct!"
    update_oled()
    # Flash all LEDs green using macropad.pixels
    macropad.pixels.fill(0x00FF00)
    macropad.pixels.show()
    # Play a success tone (e.g., a short upward arpeggio) using macropad.start_tone and macropad.stop_tone
    success_tones = [523, 659, 784] # C5, E5, G5
    for tone in success_tones:
        macropad.start_tone(tone)
        time.sleep(0.08)
        macropad.stop_tone()
    macropad.pixels.fill(0x000000)
    macropad.pixels.show()
    time.sleep(0.5)

# Function to provide negative feedback (Game Over)
def failure_feedback():
    game_status_label.text = "Wrong! Game Over"
    update_oled()
    # Flash all LEDs red using macropad.pixels
    macropad.pixels.fill(0xFF0000)
    macropad.pixels.show()
    # Play a failure tone (e.g., a descending tone) using macropad.start_tone and macropad.stop_tone
    failure_tones = [392, 330, 262] # G4, E4, C4
    for tone in failure_tones:
        macropad.start_tone(tone)
        time.sleep(0.12)
        macropad.stop_tone()
    macropad.pixels.fill(0x000000)
    macropad.pixels.show()
    time.sleep(1) # Longer pause for game over

# Function to reset and start a new game
def start_new_game():
    global game_sequence, player_input_sequence, current_level, game_over, game_started
    game_sequence.clear()
    player_input_sequence.clear()
    current_level = 0
    game_over = False
    game_started = True
    game_status_label.text = "Get ready!"
    update_oled()
    macropad.pixels.fill(0x000000) # Ensure all pixels are off
    macropad.pixels.show()
    time.sleep(1) # Small delay before starting first round

# --- Main Game Loop ---

# Initial state: waiting for user to press any key to start
game_status_label.text = "Press any key to start!"
update_oled()

while True:
    # Update encoder switch debouncing for reliable key event capture
    macropad.encoder_switch_debounced.update()

    if game_over:
        game_status_label.text = f"Game Over! Max: {max_level_achieved}\nPress any key to restart."
        update_oled()

        # Wait for any key press to restart using macropad.keys.events.get()
        event = macropad.keys.events.get()
        if event and event.pressed:
            start_new_game()
    else:
        # Game is active

        # Add a new random key to the sequence
        next_key = random.randint(0, 11) # Keys are 0-11
        game_sequence.append(next_key)
        current_level += 1
        if current_level > max_level_achieved:
            max_level_achieved = current_level
        update_oled()

        # Play the sequence
        play_game_sequence()

        # Get player input and check if it's correct
        is_player_correct = get_player_input(current_level)

        if is_player_correct and player_input_sequence == game_sequence:
            success_feedback()
            time.sleep(0.5) # Pause before next round
        else:
            # Player made a mistake or timed out
            failure_feedback()
            game_over = True # Set game over flag

    time.sleep(0.01) # Small delay to yield control and prevent busy-waiting
